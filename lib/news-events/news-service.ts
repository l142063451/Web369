/**
 * News Service Layer for PR12 - News/Notices/Events
 * Implements blog/news system with SEO and OpenGraph support
 */

import { z } from 'zod'
import { prisma } from '@/lib/db'
import DOMPurify from 'isomorphic-dompurify'
import { createAuditLog } from '@/lib/auth/audit-logger'

// Type definitions for News (will be generated by Prisma)
export type NewsStatus = 'DRAFT' | 'STAGED' | 'PUBLISHED'

export interface News {
  id: string
  title: string
  slug: string
  excerpt?: string
  content: string
  featuredImage?: string
  tags: string[]
  status: NewsStatus
  publishedAt?: Date
  seo: any
  createdBy: string
  updatedBy: string
  createdAt: Date
  updatedAt: Date
}

// Validation schemas
export const CreateNewsSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
  slug: z.string()
    .min(1, 'Slug is required')
    .max(100, 'Slug too long')
    .regex(/^[a-z0-9-]+$/, 'Slug must contain only lowercase letters, numbers, and hyphens'),
  excerpt: z.string().max(500, 'Excerpt too long').optional(),
  content: z.string().min(1, 'Content is required'),
  featuredImage: z.string().url().optional(),
  tags: z.array(z.string().min(1).max(50)).max(10, 'Too many tags').default([]),
  status: z.enum(['DRAFT', 'STAGED', 'PUBLISHED']).default('DRAFT'),
  publishedAt: z.date().optional(),
  seo: z.object({
    title: z.string().max(60).optional(),
    description: z.string().max(160).optional(),
    keywords: z.array(z.string()).optional(),
    ogImage: z.string().url().optional(),
  }).default({})
})

export const UpdateNewsSchema = CreateNewsSchema.partial().extend({
  id: z.string().cuid()
})

export const NewsFiltersSchema = z.object({
  status: z.enum(['DRAFT', 'STAGED', 'PUBLISHED']).optional(),
  tags: z.array(z.string()).optional(),
  search: z.string().optional(),
  page: z.number().int().positive().default(1),
  limit: z.number().int().positive().max(100).default(10)
})

export class NewsService {
  /**
   * Create a new news article
   */
  static async create(data: z.infer<typeof CreateNewsSchema>, userId: string): Promise<News> {
    const validated = CreateNewsSchema.parse(data)
    
    // Sanitize content
    const sanitizedContent = DOMPurify.sanitize(validated.content, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'h2', 'h3', 'h4', 'ul', 'ol', 'li', 'blockquote', 'a'],
      ALLOWED_ATTR: ['href', 'target', 'rel']
    })

    try {
      const news = await prisma.news.create({
        data: {
          ...validated,
          content: sanitizedContent,
          createdBy: userId,
          updatedBy: userId,
          publishedAt: validated.status === 'PUBLISHED' ? (validated.publishedAt || new Date()) : null
        }
      })

      // Create audit log
      await createAuditLog({
        action: 'CREATE',
        resource: 'News',
        resourceId: news.id,
        actorId: userId,
        diff: { after: news }
      })

      return news as News
    } catch (error: any) {
      if (error.code === 'P2002' && error.meta?.target?.includes('slug')) {
        throw new Error('News article with this slug already exists')
      }
      throw error
    }
  }

  /**
   * Update an existing news article
   */
  static async update(data: z.infer<typeof UpdateNewsSchema>, userId: string): Promise<News> {
    const validated = UpdateNewsSchema.parse(data)
    const { id, ...updateData } = validated

    // Get existing news for audit
    const existingNews = await prisma.news.findUnique({
      where: { id }
    })

    if (!existingNews) {
      throw new Error('News article not found')
    }

    // Sanitize content if provided
    let sanitizedContent = updateData.content
    if (updateData.content) {
      sanitizedContent = DOMPurify.sanitize(updateData.content, {
        ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'h2', 'h3', 'h4', 'ul', 'ol', 'li', 'blockquote', 'a'],
        ALLOWED_ATTR: ['href', 'target', 'rel']
      })
    }

    const updatedData = {
      ...updateData,
      ...(sanitizedContent && { content: sanitizedContent }),
      updatedBy: userId,
      // Auto-set publishedAt if status changes to PUBLISHED
      ...(updateData.status === 'PUBLISHED' && !existingNews.publishedAt && {
        publishedAt: updateData.publishedAt || new Date()
      })
    }

    try {
      const news = await prisma.news.update({
        where: { id },
        data: updatedData
      })

      // Create audit log
      await createAuditLog({
        action: 'UPDATE',
        resource: 'News',
        resourceId: news.id,
        actorId: userId,
        diff: { before: existingNews, after: news }
      })

      return news as News
    } catch (error: any) {
      if (error.code === 'P2002' && error.meta?.target?.includes('slug')) {
        throw new Error('News article with this slug already exists')
      }
      throw error
    }
  }

  /**
   * Delete a news article
   */
  static async delete(id: string, userId: string): Promise<void> {
    const existingNews = await prisma.news.findUnique({
      where: { id }
    })

    if (!existingNews) {
      throw new Error('News article not found')
    }

    await prisma.news.delete({
      where: { id }
    })

    // Create audit log
    await createAuditLog({
      action: 'DELETE',
      resource: 'News',
      resourceId: id,
      actorId: userId,
      diff: { before: existingNews }
    })
  }

  /**
   * Get news by ID
   */
  static async getById(id: string): Promise<News | null> {
    const news = await prisma.news.findUnique({
      where: { id },
      include: {
        creator: {
          select: { id: true, name: true, email: true }
        },
        updater: {
          select: { id: true, name: true, email: true }
        }
      }
    })

    return news as News | null
  }

  /**
   * Get news by slug
   */
  static async getBySlug(slug: string): Promise<News | null> {
    const news = await prisma.news.findUnique({
      where: { slug },
      include: {
        creator: {
          select: { id: true, name: true, email: true }
        },
        updater: {
          select: { id: true, name: true, email: true }
        }
      }
    })

    return news as News | null
  }

  /**
   * List news with filtering and pagination
   */
  static async list(filters: z.infer<typeof NewsFiltersSchema>) {
    const validated = NewsFiltersSchema.parse(filters)
    const { page, limit, status, tags, search } = validated

    const where: any = {}

    // Status filter
    if (status) {
      where.status = status
    }

    // Tags filter
    if (tags && tags.length > 0) {
      where.tags = {
        hassome: tags
      }
    }

    // Search filter
    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { excerpt: { contains: search, mode: 'insensitive' } },
        { content: { contains: search, mode: 'insensitive' } }
      ]
    }

    const [news, total] = await Promise.all([
      prisma.news.findMany({
        where,
        orderBy: [
          { publishedAt: 'desc' },
          { createdAt: 'desc' }
        ],
        skip: (page - 1) * limit,
        take: limit,
        include: {
          creator: {
            select: { id: true, name: true, email: true }
          }
        }
      }),
      prisma.news.count({ where })
    ])

    return {
      news: news as News[],
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    }
  }

  /**
   * Get published news for public display
   */
  static async getPublished(page = 1, limit = 10) {
    return this.list({
      status: 'PUBLISHED',
      page,
      limit
    })
  }

  /**
   * Get news by tag
   */
  static async getByTag(tag: string, page = 1, limit = 10) {
    return this.list({
      status: 'PUBLISHED',
      tags: [tag],
      page,
      limit
    })
  }

  /**
   * Get all unique tags
   */
  static async getTags(): Promise<string[]> {
    const news = await prisma.news.findMany({
      where: { status: 'PUBLISHED' },
      select: { tags: true }
    })

    const allTags = news.flatMap((n: any) => n.tags)
    return Array.from(new Set(allTags as string[])).sort()
  }

  /**
   * Search published news
   */
  static async search(query: string, page = 1, limit = 10) {
    return this.list({
      status: 'PUBLISHED',
      search: query,
      page,
      limit
    })
  }

  /**
   * Generate SEO metadata for news article
   */
  static generateSEO(article: { 
    title: string
    excerpt?: string
    featuredImage?: string
    tags?: string[]
  }) {
    const siteTitle = 'Ummid Se Hari'
    const defaultTags = ['Ummid Se Hari', 'village news']
    
    return {
      title: `${article.title} | ${siteTitle}`,
      description: article.excerpt || article.title,
      keywords: [...(article.tags || []), ...defaultTags],
      openGraph: {
        title: article.title,
        description: article.excerpt || article.title,
        images: article.featuredImage ? [article.featuredImage] : [],
        type: 'article',
        siteName: siteTitle
      },
      twitter: {
        card: 'summary_large_image',
        title: article.title,
        description: article.excerpt || article.title,
        ...(article.featuredImage && { images: [article.featuredImage] })
      }
    }
  }
}